<<<<<<< HEAD
import { promisify } from 'util';
import * as zlib from 'zlib';

import { LEGACY_HELLO_COMMAND } from '../../constants';
import { getSnappy, getZstdLibrary, type SnappyLib, type ZStandard } from '../../deps';
import { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';
import {
  type MessageHeader,
  OpCompressedRequest,
  OpMsgResponse,
  OpReply,
  type WriteProtocolMessageType
} from '../commands';
import { OP_COMPRESSED, OP_MSG } from './constants';
=======
import * as zlib from 'zlib';

import { LEGACY_HELLO_COMMAND } from '../../constants';
import { PKG_VERSION, Snappy, ZStandard } from '../../deps';
import { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';
import type { Callback } from '../../utils';
import type { OperationDescription } from '../message_stream';
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909

/** @public */
export const Compressor = Object.freeze({
  none: 0,
  snappy: 1,
  zlib: 2,
  zstd: 3
} as const);

/** @public */
export type Compressor = (typeof Compressor)[CompressorName];

/** @public */
export type CompressorName = keyof typeof Compressor;

export const uncompressibleCommands = new Set([
  LEGACY_HELLO_COMMAND,
  'saslStart',
  'saslContinue',
  'getnonce',
  'authenticate',
  'createUser',
  'updateUser',
  'copydbSaslStart',
  'copydbgetnonce',
  'copydb'
]);

<<<<<<< HEAD
const ZSTD_COMPRESSION_LEVEL = 3;

const zlibInflate = promisify(zlib.inflate.bind(zlib));
const zlibDeflate = promisify(zlib.deflate.bind(zlib));

let zstd: ZStandard;
let Snappy: SnappyLib | null = null;
function loadSnappy() {
  if (Snappy == null) {
    const snappyImport = getSnappy();
    if ('kModuleError' in snappyImport) {
      throw snappyImport.kModuleError;
    }
    Snappy = snappyImport;
  }
  return Snappy;
}

// Facilitate compressing a message using an agreed compressor
export async function compress(
  options: { zlibCompressionLevel: number; agreedCompressor: CompressorName },
  dataToBeCompressed: Buffer
): Promise<Buffer> {
  const zlibOptions = {} as zlib.ZlibOptions;
  switch (options.agreedCompressor) {
    case 'snappy': {
      Snappy ??= loadSnappy();
      return await Snappy.compress(dataToBeCompressed);
    }
    case 'zstd': {
      loadZstd();
      if ('kModuleError' in zstd) {
        throw zstd['kModuleError'];
      }
      return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
    }
    case 'zlib': {
      if (options.zlibCompressionLevel) {
        zlibOptions.level = options.zlibCompressionLevel;
      }
      return await zlibDeflate(dataToBeCompressed, zlibOptions);
    }
    default: {
      throw new MongoInvalidArgumentError(
        `Unknown compressor ${options.agreedCompressor} failed to compress`
      );
    }
=======
const MAX_COMPRESSOR_ID = 3;
const ZSTD_COMPRESSION_LEVEL = 3;

// Facilitate compressing a message using an agreed compressor
export function compress(
  self: { options: OperationDescription & zlib.ZlibOptions },
  dataToBeCompressed: Buffer,
  callback: Callback<Buffer>
): void {
  const zlibOptions = {} as zlib.ZlibOptions;
  switch (self.options.agreedCompressor) {
    case 'snappy': {
      if ('kModuleError' in Snappy) {
        return callback(Snappy['kModuleError']);
      }

      if (Snappy[PKG_VERSION].major <= 6) {
        Snappy.compress(dataToBeCompressed, callback);
      } else {
        Snappy.compress(dataToBeCompressed).then(
          buffer => callback(undefined, buffer),
          error => callback(error)
        );
      }
      break;
    }
    case 'zlib':
      // Determine zlibCompressionLevel
      if (self.options.zlibCompressionLevel) {
        zlibOptions.level = self.options.zlibCompressionLevel;
      }
      zlib.deflate(dataToBeCompressed, zlibOptions, callback as zlib.CompressCallback);
      break;
    case 'zstd':
      if ('kModuleError' in ZStandard) {
        return callback(ZStandard['kModuleError']);
      }
      ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(
        buffer => callback(undefined, buffer),
        error => callback(error)
      );
      break;
    default:
      throw new MongoInvalidArgumentError(
        `Unknown compressor ${self.options.agreedCompressor} failed to compress`
      );
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
  }
}

// Decompress a message using the given compressor
<<<<<<< HEAD
export async function decompress(compressorID: number, compressedData: Buffer): Promise<Buffer> {
  if (
    compressorID !== Compressor.snappy &&
    compressorID !== Compressor.zstd &&
    compressorID !== Compressor.zlib &&
    compressorID !== Compressor.none
  ) {
=======
export function decompress(
  compressorID: Compressor,
  compressedData: Buffer,
  callback: Callback<Buffer>
): void {
  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
    throw new MongoDecompressionError(
      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`
    );
  }

  switch (compressorID) {
    case Compressor.snappy: {
<<<<<<< HEAD
      Snappy ??= loadSnappy();
      return await Snappy.uncompress(compressedData, { asBuffer: true });
    }
    case Compressor.zstd: {
      loadZstd();
      if ('kModuleError' in zstd) {
        throw zstd['kModuleError'];
      }
      return await zstd.decompress(compressedData);
    }
    case Compressor.zlib: {
      return await zlibInflate(compressedData);
    }
    default: {
      return compressedData;
    }
  }
}

/**
 * Load ZStandard if it is not already set.
 */
function loadZstd() {
  if (!zstd) {
    zstd = getZstdLibrary();
  }
}

const MESSAGE_HEADER_SIZE = 16;

/**
 * @internal
 *
 * Compresses an OP_MSG or OP_QUERY message, if compression is configured.  This method
 * also serializes the command to BSON.
 */
export async function compressCommand(
  command: WriteProtocolMessageType,
  description: { agreedCompressor?: CompressorName; zlibCompressionLevel?: number }
): Promise<Buffer> {
  const finalCommand =
    description.agreedCompressor === 'none' || !OpCompressedRequest.canCompress(command)
      ? command
      : new OpCompressedRequest(command, {
          agreedCompressor: description.agreedCompressor ?? 'none',
          zlibCompressionLevel: description.zlibCompressionLevel ?? 0
        });
  const data = await finalCommand.toBin();
  return Buffer.concat(data);
}

/**
 * @internal
 *
 * Decompresses an OP_MSG or OP_QUERY response from the server, if compression is configured.
 *
 * This method does not parse the response's BSON.
 */
export async function decompressResponse(message: Buffer): Promise<OpMsgResponse | OpReply> {
  const messageHeader: MessageHeader = {
    length: message.readInt32LE(0),
    requestId: message.readInt32LE(4),
    responseTo: message.readInt32LE(8),
    opCode: message.readInt32LE(12)
  };

  if (messageHeader.opCode !== OP_COMPRESSED) {
    const ResponseType = messageHeader.opCode === OP_MSG ? OpMsgResponse : OpReply;
    const messageBody = message.subarray(MESSAGE_HEADER_SIZE);
    return new ResponseType(message, messageHeader, messageBody);
  }

  const header: MessageHeader = {
    ...messageHeader,
    fromCompressed: true,
    opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),
    length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)
  };
  const compressorID = message[MESSAGE_HEADER_SIZE + 8];
  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);

  // recalculate based on wrapped opcode
  const ResponseType = header.opCode === OP_MSG ? OpMsgResponse : OpReply;
  const messageBody = await decompress(compressorID, compressedBuffer);
  if (messageBody.length !== header.length) {
    throw new MongoDecompressionError('Message body and message header must be the same length');
  }
  return new ResponseType(message, header, messageBody);
}
=======
      if ('kModuleError' in Snappy) {
        return callback(Snappy['kModuleError']);
      }

      if (Snappy[PKG_VERSION].major <= 6) {
        Snappy.uncompress(compressedData, { asBuffer: true }, callback);
      } else {
        Snappy.uncompress(compressedData, { asBuffer: true }).then(
          buffer => callback(undefined, buffer),
          error => callback(error)
        );
      }
      break;
    }
    case Compressor.zstd: {
      if ('kModuleError' in ZStandard) {
        return callback(ZStandard['kModuleError']);
      }

      ZStandard.decompress(compressedData).then(
        buffer => callback(undefined, buffer),
        error => callback(error)
      );
      break;
    }
    case Compressor.zlib:
      zlib.inflate(compressedData, callback as zlib.CompressCallback);
      break;
    default:
      callback(undefined, compressedData);
  }
}
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
