import type { Document } from '../../bson';
import { MongoRuntimeError } from '../../error';
<<<<<<< HEAD
import type { HandshakeDocument } from '../connect';
import type { Connection, ConnectionOptions } from '../connection';
import type { MongoCredentials } from './mongo_credentials';

=======
import type { Callback } from '../../utils';
import type { HandshakeDocument } from '../connect';
import type { Connection, ConnectionOptions } from '../connection';
import type { ClientMetadataOptions } from '../handshake/client_metadata';
import type { MongoCredentials } from './mongo_credentials';

export type AuthContextOptions = ConnectionOptions & ClientMetadataOptions;

>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
/**
 * Context used during authentication
 * @internal
 */
export class AuthContext {
  /** The connection to authenticate */
  connection: Connection;
  /** The credentials to use for authentication */
  credentials?: MongoCredentials;
<<<<<<< HEAD
  /** If the context is for reauthentication. */
  reauthenticating = false;
=======
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
  /** The options passed to the `connect` method */
  options: ConnectionOptions;

  /** A response from an initial auth attempt, only some mechanisms use this (e.g, SCRAM) */
  response?: Document;
  /** A random nonce generated for use in an authentication conversation */
  nonce?: Buffer;

  constructor(
    connection: Connection,
    credentials: MongoCredentials | undefined,
    options: ConnectionOptions
  ) {
    this.connection = connection;
    this.credentials = credentials;
    this.options = options;
  }
}

<<<<<<< HEAD
/**
 * Provider used during authentication.
 * @internal
 */
export abstract class AuthProvider {
=======
export class AuthProvider {
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
  /**
   * Prepare the handshake document before the initial handshake.
   *
   * @param handshakeDoc - The document used for the initial handshake on a connection
   * @param authContext - Context for authentication flow
   */
<<<<<<< HEAD
  async prepare(
    handshakeDoc: HandshakeDocument,
    _authContext: AuthContext
  ): Promise<HandshakeDocument> {
    return handshakeDoc;
=======
  prepare(
    handshakeDoc: HandshakeDocument,
    authContext: AuthContext,
    callback: Callback<HandshakeDocument>
  ): void {
    callback(undefined, handshakeDoc);
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
  }

  /**
   * Authenticate
   *
   * @param context - A shared context for authentication flow
<<<<<<< HEAD
   */
  abstract auth(context: AuthContext): Promise<void>;

  /**
   * Reauthenticate.
   * @param context - The shared auth context.
   */
  async reauth(context: AuthContext): Promise<void> {
    if (context.reauthenticating) {
      throw new MongoRuntimeError('Reauthentication already in progress.');
    }
    try {
      context.reauthenticating = true;
      await this.auth(context);
    } finally {
      context.reauthenticating = false;
    }
=======
   * @param callback - The callback to return the result from the authentication
   */
  auth(context: AuthContext, callback: Callback): void {
    // TODO(NODE-3483): Replace this with MongoMethodOverrideError
    callback(new MongoRuntimeError('`auth` method must be overridden by subclass'));
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
  }
}
