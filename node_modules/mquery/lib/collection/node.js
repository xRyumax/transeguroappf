'use strict';

/**
 * Module dependencies
 */

const Collection = require('./collection');

class NodeCollection extends Collection {
  constructor(col) {
    super();

    this.collection = col;
    this.collectionName = col.collectionName;
  }

  /**
<<<<<<< HEAD
   * find(match, options)
   */
  async find(match, options) {
    const cursor = this.collection.find(match, options);

    return cursor.toArray();
  }

  /**
   * findOne(match, options)
   */
  async findOne(match, options) {
    return this.collection.findOne(match, options);
  }

  /**
   * count(match, options)
   */
  async count(match, options) {
    return this.collection.count(match, options);
  }

  /**
   * distinct(prop, match, options)
   */
  async distinct(prop, match, options) {
    return this.collection.distinct(prop, match, options);
  }

  /**
   * updateMany(match, update, options)
   */
  async updateMany(match, update, options) {
    return this.collection.updateMany(match, update, options);
  }

  /**
   * updateOne(match, update, options)
   */
  async updateOne(match, update, options) {
    return this.collection.updateOne(match, update, options);
  }

  /**
   * replaceOne(match, update, options)
   */
  async replaceOne(match, update, options) {
    return this.collection.replaceOne(match, update, options);
  }

  /**
   * deleteOne(match, options)
   */
  async deleteOne(match, options) {
    return this.collection.deleteOne(match, options);
  }

  /**
   * deleteMany(match, options)
   */
  async deleteMany(match, options) {
    return this.collection.deleteMany(match, options);
=======
   * find(match, options, function(err, docs))
   */
  find(match, options, cb) {
    const cursor = this.collection.find(match, options);

    try {
      cursor.toArray(cb);
    } catch (error) {
      cb(error);
    }
  }

  /**
   * findOne(match, options, function(err, doc))
   */
  findOne(match, options, cb) {
    this.collection.findOne(match, options, cb);
  }

  /**
   * count(match, options, function(err, count))
   */
  count(match, options, cb) {
    this.collection.count(match, options, cb);
  }

  /**
   * distinct(prop, match, options, function(err, count))
   */
  distinct(prop, match, options, cb) {
    this.collection.distinct(prop, match, options, cb);
  }

  /**
   * update(match, update, options, function(err[, result]))
   */
  update(match, update, options, cb) {
    this.collection.update(match, update, options, cb);
  }

  /**
   * update(match, update, options, function(err[, result]))
   */
  updateMany(match, update, options, cb) {
    this.collection.updateMany(match, update, options, cb);
  }

  /**
   * update(match, update, options, function(err[, result]))
   */
  updateOne(match, update, options, cb) {
    this.collection.updateOne(match, update, options, cb);
  }

  /**
   * replaceOne(match, update, options, function(err[, result]))
   */
  replaceOne(match, update, options, cb) {
    this.collection.replaceOne(match, update, options, cb);
  }

  /**
   * deleteOne(match, options, function(err[, result])
   */
  deleteOne(match, options, cb) {
    this.collection.deleteOne(match, options, cb);
  }

  /**
   * deleteMany(match, options, function(err[, result])
   */
  deleteMany(match, options, cb) {
    this.collection.deleteMany(match, options, cb);
  }

  /**
   * remove(match, options, function(err[, result])
   */
  remove(match, options, cb) {
    this.collection.remove(match, options, cb);
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
  }

  /**
   * findOneAndDelete(match, options, function(err[, result])
   */
<<<<<<< HEAD
  async findOneAndDelete(match, options) {
    return this.collection.findOneAndDelete(match, options);
  }

  /**
   * findOneAndUpdate(match, update, options)
   */
  async findOneAndUpdate(match, update, options) {
    return this.collection.findOneAndUpdate(match, update, options);
=======
  findOneAndDelete(match, options, cb) {
    this.collection.findOneAndDelete(match, options, cb);
  }

  /**
   * findOneAndUpdate(match, update, options, function(err[, result])
   */
  findOneAndUpdate(match, update, options, cb) {
    this.collection.findOneAndUpdate(match, update, options, cb);
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
  }

  /**
   * var cursor = findCursor(match, options)
   */
  findCursor(match, options) {
    return this.collection.find(match, options);
  }

  /**
<<<<<<< HEAD
   * aggregation(operators...)
=======
   * aggregation(operators..., function(err, doc))
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
   * TODO
   */
}


/**
 * Expose
 */

module.exports = exports = NodeCollection;
